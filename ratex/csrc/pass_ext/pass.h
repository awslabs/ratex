/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

/*!
 * \file pass.h
 * \brief Customized RAF passes
 */
#pragma once

#include "raf/pass.h"

namespace raf {
namespace pass {

/*!
 * \brief Eliminate the closure in returned value. Replace them with constant 1s.
 * \return The pass.
 */
Pass EliminateClosure();

/*!
 * \brief Wrap identity output values with raf.op.copy
 * \return The pass.
 */
Pass WrapIdentity();

/*!
 * \brief Canonicalize parameters of the backward closure generated by AutoDiff.
 * \return The pass.
 */
Pass CanonicalizeParamsForRATEX();

/*!
 * \brief Analyze the IR to get a mapping from output tuple indices to input
 * argument indices that share the same memory (inplace update).
 * \return The pass.
 */
Pass InplaceUpdateAnalysis();

/*!
 * \brief Mutate the IR to attach in-place update information according to the given alias map.
 * Note that we cannot simply mark may_share because the IR may be transformed to GNF and erase
 * the alias information. Thus, for now we only update the ops with "out" in their arguments.
 */
Pass InplaceUpdateByAlias(ir::Map<tvm::Integer, tvm::Integer> alias_map);

/*!
 * \brief Mutate the IR as describled below:
 * (1) cast all the constant float32 tensors to constant bf16/fp16 tensors;
 * (2) if a cast call's target dtype is float32, we change the target dtype to bf16/fp16
 * \param bf_fp_16_dtype indicates the target dtype (bf16 or fp16)
 */
Pass ConvertBfFp16Constant(tvm::String bf_fp_16_dtype);

}  // namespace pass
}  // namespace raf
